<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>StreamSports - Premium Player</title>
    <!-- Hls.js -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <!-- Google Cast SDK -->
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"
        onload="console.log('DEBUG: Cast SDK script loaded')"
        onerror="console.error('DEBUG: Cast SDK script FAILED to load')"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Palette: Deep Space / Neon */
            --bg-body: #050505;
            --bg-surface: #121212;
            --bg-glass: rgba(20, 20, 20, 0.7);
            --border-glass: rgba(255, 255, 255, 0.08);

            --primary: #6366f1;
            --primary-glow: rgba(99, 102, 241, 0.4);
            --accent: #06b6d4;

            --text-main: #ffffff;
            --text-muted: #a1a1aa;

            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- Scrollbar --- */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* --- Glass Header --- */
        header {
            height: 72px;
            padding: 0 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-glass);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-bottom: 1px solid var(--border-glass);
            z-index: 50;
            flex-shrink: 0;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.4rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            color: white;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .brand:hover {
            opacity: 0.8;
        }

        .brand svg {
            color: var(--primary);
            filter: drop-shadow(0 0 8px var(--primary-glow));
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .search-box {
            position: relative;
            width: 300px;
        }

        .search-box input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-glass);
            padding: 10px 16px 10px 40px;
            border-radius: 50px;
            color: white;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .search-box input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }

        .search-icon {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            pointer-events: none;
        }

        .nav-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.03);
            padding: 4px;
            border-radius: 50px;
            border: 1px solid var(--border-glass);
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            padding: 8px 24px;
            border-radius: 40px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .nav-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 12px var(--primary-glow);
        }

        /* --- Main Layout --- */
        .layout {
            display: flex;
            flex: 1;
            height: calc(100vh - 72px);
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 380px;
            display: flex;
            flex-direction: column;
            background: var(--bg-surface);
            border-right: 1px solid var(--border-glass);
            flex-shrink: 0;
            transition: width 0.3s ease;
            position: relative;
        }

        .filters-area {
            padding: 16px;
            border-bottom: 1px solid var(--border-glass);
            flex-shrink: 0;
        }

        .filter-select {
            width: 100%;
            background: #1a1a1a;
            color: white;
            border: 1px solid var(--border-glass);
            padding: 12px;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            appearance: none;
            cursor: pointer;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
        }

        .filter-select:hover {
            border-color: #444;
        }

        .chips-scroll {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 4px;
        }

        .chip {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-glass);
            padding: 6px 14px;
            border-radius: 20px;
            color: var(--text-muted);
            font-size: 0.85rem;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .chip.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* --- Lists (Grid vs List) --- */
        .content-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* Channel List View */
        .channel-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .channel-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .channel-item:hover {
            background: rgba(255, 255, 255, 0.06);
            transform: translateX(4px);
        }

        .channel-item.playing {
            background: rgba(99, 102, 241, 0.15);
            border-color: var(--primary);
        }

        .channel-logo {
            width: 48px;
            height: 48px;
            background: #000;
            border-radius: var(--radius-sm);
            object-fit: contain;
            padding: 4px;
            margin-right: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .channel-info {
            flex: 1;
            overflow: hidden;
        }

        .channel-name {
            font-weight: 600;
            font-size: 1rem;
            color: white;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .channel-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .flag-badge {
            text-transform: uppercase;
            font-weight: 700;
            color: var(--accent);
            opacity: 0.9;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .status-badge.online {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }

        .status-badge.offline {
            background: rgba(100, 116, 139, 0.2);
            color: #94a3b8;
        }

        /* Event Grid View */
        .events-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            grid-auto-rows: minmax(120px, auto);
            /* CRITICAL: Prevent row collapse */
            gap: 16px;
        }

        .event-card {
            background: #1a1a1a;
            border-radius: var(--radius-lg);
            overflow: hidden;
            border: 1px solid var(--border-glass);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            min-height: 120px;
            /* CRITICAL: Prevent card collapse */
        }

        .event-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            border-color: #444;
        }

        .event-card-header {
            padding: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.05), transparent);
        }

        .team-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .vs-badge {
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--text-muted);
        }

        .event-card-body {
            padding: 16px;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .event-title {
            font-weight: 700;
            font-size: 1.1rem;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .event-meta {
            font-size: 0.85rem;
            color: var(--accent);
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .live-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
            box-shadow: 0 0 8px #ef4444;
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* --- Player Area --- */
        .player-area {
            flex: 1;
            background: black;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
        }

        video {
            width: 100%;
            height: 100%;
            max-height: 100vh;
        }

        .placeholder-content {
            text-align: center;
            opacity: 0.4;
            max-width: 400px;
        }

        .placeholder-content h1 {
            font-size: 2rem;
            margin-bottom: 12px;
            color: white;
        }

        /* --- Loader --- */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #050505;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(99, 102, 241, 0.3);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s infinite linear;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Player Loading Spinner */
        #playerLoader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        /* Server List */
        .server-list-container {
            display: none;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-surface);
            border-bottom: 1px solid var(--border-glass);
        }

        .server-label {
            color: var(--text-muted);
            font-size: 0.85rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .server-scroller {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            flex: 1;
        }

        .server-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .server-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary);
        }

        .server-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        .server-btn img {
            width: 20px;
            height: 15px;
            border-radius: 2px;
        }

        .server-info {
            display: flex;
            flex-direction: column;
        }

        .server-name {
            color: white;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .server-meta {
            color: var(--text-muted);
            font-size: 0.7rem;
        }



        /* --- Mobile Responsiveness --- */
        @media (max-width: 768px) {
            body {
                height: 100%;
                overflow-y: auto;
            }

            header {
                padding: 0 16px;
                height: 60px;
                flex-wrap: nowrap;
                /* Single row */
                gap: 0;
            }

            .brand {
                display: none;
                /* Hide brand completely */
            }

            .controls {
                width: 100%;
                gap: 6px;
                justify-content: space-between;
            }

            .search-box {
                display: block;
                width: auto;
                flex: 1;
                /* Maximize search space */
                order: unset;
                /* Normal flow */
                margin-top: 0;
            }

            .search-box input {
                width: 100%;
                padding: 10px 16px 10px 40px;
            }

            .search-icon {
                left: 14px;
            }

            .layout {
                flex-direction: column;
                height: auto;
            }

            .player-area {
                width: 100%;
                height: 250px;
                /* Fixed height for video on mobile */
                min-height: 250px;
                position: sticky;
                top: 0;
                z-index: 100;
                order: -1;
                /* Ensure player is on top */
            }

            .sidebar {
                width: 100% !important;
                /* Force full width */
                height: auto;
                border-right: none;
                flex: 1;
            }

            .content-scroll {
                max-height: none;
                /* Let the page scroll naturally */
                overflow: visible;
            }

            .placeholder-content h1 {
                font-size: 1.5rem;
            }

            .placeholder-content p {
                font-size: 0.9rem;
                padding: 0 20px;
            }

            /* Compact switch for mobile */


            .nav-btn {
                padding: 6px 8px;
                font-size: 0.95rem;
            }

            /* Compact stats for mobile */
            .debug-footer {
                position: relative;
            }
        }
    </style>
</head>

<body>

    <!-- Header -->
    <header>
        <div class="brand" onclick="goHome()">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <!-- TV with Play Button (Sports Streaming) -->
                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                <polygon points="10 8 16 11 10 14 10 8" fill="currentColor" stroke="none"></polygon>
                <line x1="8" y1="21" x2="16" y2="21"></line>
                <line x1="12" y1="17" x2="12" y2="21"></line>
            </svg>
            <span>StreamSports</span>
        </div>

        <div class="controls">
            <div class="search-box">
                <span class="search-icon">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                </span>
                <input type="text" id="searchInput" placeholder="Search events, channels, teams...">
            </div>

            <div class="nav-tabs">
                <button class="nav-btn active" onclick="switchTab('events')">Sports Events</button>
                <button class="nav-btn" onclick="switchTab('channels')">TV Channels</button>
            </div>
        </div>
    </header>

    <!-- Main Layout -->
    <div class="layout">

        <!-- Interactive Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="filters-area" id="filtersArea">
                <!-- Injected via JS -->
            </div>

            <div class="content-scroll" id="contentList">
                <!-- Items Injected Here -->
            </div>


        </div>

        <div id="playerContainer" class="player-container" style="display: flex; flex-direction: column; flex: 1;">
            <!-- Server List Header -->
            <div id="serverListContainer" class="server-list-container">
                <span class="server-label">Servers:</span>
                <div id="serverList" class="server-scroller">
                    <!-- Buttons injected here -->
                </div>
            </div>

            <!-- Cinema Player -->
            <div class="player-area" style="flex: 1;">
                <div id="playerPlaceholder" class="placeholder-content">
                    <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"
                        style="margin-bottom: 24px;">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polygon points="10 8 16 12 10 16 10 8" fill="currentColor" stroke="none"></polygon>
                    </svg>
                    <h1>Select a Stream</h1>
                    <p>Choose a live TV channel or sports event from the sidebar to start watching in HD.</p>
                </div>
                <div id="playerLoader">
                    <div class="spinner"></div>
                </div>

                <!-- Loading Toast (top-right) -->
                <div id="loadingToast" style="
                    position: absolute;
                    top: 16px;
                    right: 16px;
                    background: rgba(99, 102, 241, 0.95);
                    color: white;
                    padding: 10px 16px;
                    border-radius: 8px;
                    font-size: 0.9rem;
                    font-weight: 500;
                    display: none;
                    align-items: center;
                    gap: 10px;
                    z-index: 30;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
                    animation: fadeIn 0.2s ease;
                ">
                    <div
                        style="width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 0.8s linear infinite;">
                    </div>
                    <span id="loadingToastText">Loading...</span>
                </div>

                <video id="videoPlayer" style="display: none; width: 100%; height: 100%; background: #000;"></video>

                <!-- Custom Integrated Controls Bar -->
                <div id="customControls" style="
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 70%, transparent 100%);
                padding: 12px 16px 16px 16px;
                display: none;
                flex-direction: column;
                gap: 8px;
                transition: opacity 0.3s ease;
                z-index: 10;
            ">
                    <!-- Progress Bar -->
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="range" id="progressBar" min="0" max="100" value="0" style="
                        flex: 1;
                        height: 4px;
                        -webkit-appearance: none;
                        appearance: none;
                        background: rgba(255,255,255,0.3);
                        border-radius: 2px;
                        outline: none;
                        cursor: pointer;
                    ">
                    </div>

                    <!-- Control Buttons Row -->
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <!-- Play/Pause -->
                        <button id="playPauseBtn" onclick="togglePlayPause()" title="Play/Pause" style="
                        width: 36px; height: 36px; border: none; background: transparent;
                        color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                            <svg id="playIcon" width="24" height="24" viewBox="0 0 24 24" fill="white">
                                <path d="M8 5v14l11-7z" />
                            </svg>
                            <svg id="pauseIcon" width="24" height="24" viewBox="0 0 24 24" fill="white"
                                style="display:none;">
                                <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z" />
                            </svg>
                        </button>

                        <!-- Time Display -->
                        <div style="color: white; font-size: 13px; font-family: monospace; min-width: 100px;">
                            <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
                        </div>

                        <div style="flex: 1;"></div>

                        <!-- Volume -->
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <button id="muteBtn" onclick="toggleMute()" title="Mute" style="
                            width: 32px; height: 32px; border: none; background: transparent;
                            color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;
                        ">
                                <svg id="volumeIcon" width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    stroke="currentColor" stroke-width="2">
                                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                                    <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                </svg>
                            </button>
                            <input type="range" id="volumeBar" min="0" max="100" value="100" style="
                            width: 70px; height: 4px;
                            -webkit-appearance: none; appearance: none;
                            background: rgba(255,255,255,0.3); border-radius: 2px;
                            outline: none; cursor: pointer;
                        ">
                        </div>

                        <!-- Chromecast -->
                        <button id="castBtn" onclick="openCastDialog()" title="Cast" style="
                        width: 32px; height: 32px; border: none; background: transparent;
                        color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path
                                    d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6">
                                </path>
                                <circle cx="2" cy="20" r="2" fill="currentColor" stroke="none"></circle>
                            </svg>
                        </button>

                        <!-- PiP -->
                        <button id="pipBtn" onclick="togglePiP()" title="Picture-in-Picture" style="
                        width: 32px; height: 32px; border: none; background: transparent;
                        color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                                <rect x="11" y="9" width="9" height="7" rx="1" fill="currentColor" stroke="none"></rect>
                            </svg>
                        </button>

                        <!-- AirPlay -->
                        <button id="airplayBtn" onclick="toggleAirPlay()" title="AirPlay" style="
                        width: 32px; height: 32px; border: none; background: transparent;
                        color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1">
                                </path>
                                <polygon points="12 15 17 21 7 21 12 15" fill="currentColor" stroke="none"></polygon>
                            </svg>
                        </button>

                        <!-- Fullscreen -->
                        <button id="fullscreenBtn" onclick="toggleFullscreen()" title="Fullscreen" style="
                        width: 32px; height: 32px; border: none; background: transparent;
                        color: white; cursor: pointer; display: flex; align-items: center; justify-content: center;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path
                                    d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3">
                                </path>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- CSS for custom range inputs -->
                <style>
                    #progressBar::-webkit-slider-thumb,
                    #volumeBar::-webkit-slider-thumb {
                        -webkit-appearance: none;
                        appearance: none;
                        width: 12px;
                        height: 12px;
                        border-radius: 50%;
                        background: #fff;
                        cursor: pointer;
                    }

                    #progressBar::-moz-range-thumb,
                    #volumeBar::-moz-range-thumb {
                        width: 12px;
                        height: 12px;
                        border-radius: 50%;
                        background: #fff;
                        cursor: pointer;
                        border: none;
                    }
                </style>

                <!-- Error Toast (Hidden by default) -->
                <div id="errorToast"
                    style="position: absolute; bottom: 30px; background: #ef4444; color: white; padding: 12px 24px; border-radius: 8px; font-weight: 500; display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
                    Stream Offline or Unavailable
                </div>
            </div>
        </div>

        <!-- Loading Screen -->
        <div id="loading">
            <div class="spinner"></div>
        </div>

        <script>
            console.log('DEBUG: StreamSports Custom Script Loaded v2');
            window.onerror = function (msg, url, line, col, error) {
                console.error('DEBUG: GLOBAL JS ERROR:', msg, 'at', line + ':' + col, error);
            };
            // --- State Management ---
            let state = {
                channels: [],
                events: [],
                epg: {}, // id: { name, programs }
                epgMap: new Map(), // normalized_name -> epg_id
                currentFilter: 'all',
                currentTab: 'events',
                loading: false,
                tab: 'events', // Keep existing tab property
                filter: 'All' // Keep existing filter property
            };

            const els = {
                contentList: document.getElementById('contentList'),
                filtersArea: document.getElementById('filtersArea'),
                search: document.getElementById('searchInput'),
                video: document.getElementById('videoPlayer'),
                placeholder: document.getElementById('playerPlaceholder'),
                loader: document.getElementById('loading'),
                sidebar: document.getElementById('sidebar')
            };

            let hls;
            let currentStreamUrl = null;

            // --- Hydrate Event Channels with Status from TV Channels ---
            function hydrateEventChannelStatus() {
                // Build a lookup map from TV channels: normalized name -> status
                const statusMap = new Map();
                for (const ch of state.channels) {
                    if (ch.name && ch.status) {
                        const key = ch.name.toLowerCase().trim();
                        statusMap.set(key, ch.status.toLowerCase());
                    }
                }

                // Update each event's channels with status from the map
                for (const event of state.events) {
                    const channelName = event.channel_name || event.name || '';
                    const key = channelName.toLowerCase().trim();

                    if (statusMap.has(key)) {
                        event.channel_status = statusMap.get(key);
                    } else {
                        // Try partial match (event channel name contains TV channel name or vice versa)
                        for (const [mapKey, mapStatus] of statusMap) {
                            if (key.includes(mapKey) || mapKey.includes(key)) {
                                event.channel_status = mapStatus;
                                break;
                            }
                        }
                    }
                }

                console.log('Hydrated channel status for', state.events.length, 'events');
            }

            // --- Initialization ---
            async function init() {
                try {
                    const [cRes, eRes] = await Promise.all([
                        fetch('/api/channels'),
                        fetch('/api/events?sport=all')
                    ]);

                    const cData = await cRes.json();
                    const eData = await eRes.json();

                    state.channels = cData.channels || [];
                    state.events = eData.events || [];

                    // Hydrate event channels with status from TV channels
                    hydrateEventChannelStatus();

                    console.log("Loaded Events:", state.events.length);

                    renderFilters();
                    renderContent();
                    fetchEPG(); // Fetch EPG data after initial content render
                } catch (err) {
                    console.error(err);
                    alert("Failed to load initial data");
                } finally {
                    els.loader.style.opacity = '0';
                    setTimeout(() => els.loader.remove(), 500);
                }
            }

            // --- Tab Switching ---
            window.switchTab = (tab) => {
                state.tab = tab;
                state.filter = 'All';
                els.search.value = '';

                // Update Buttons
                document.querySelectorAll('.nav-btn').forEach(b =>
                    b.classList.toggle('active', b.innerText.toLowerCase().includes(tab === 'channels' ? 'tv' : 'sports'))
                );

                if (tab === 'events') {
                    els.sidebar.style.width = '650px';
                } else {
                    els.sidebar.style.width = '380px';
                }

                renderFilters();
                renderContent();
            }

            // --- Go Home (Logo Click) ---
            window.goHome = () => {
                location.reload();
            }

            // --- Filtering ---
            function renderFilters() {
                els.filtersArea.innerHTML = '';

                if (state.tab === 'channels') {
                    // Dropdown for Countries (Expanded Name Logic)
                    const countries = new Set();
                    state.channels.forEach(c => { if (c.code) countries.add(c.code.toUpperCase()); });
                    const sorted = Array.from(countries).sort((a, b) => getCountryName(a).localeCompare(getCountryName(b)));

                    const select = document.createElement('select');
                    select.className = 'filter-select';
                    select.onchange = (e) => { state.filter = e.target.value; renderContent(); };

                    select.innerHTML = `<option value="All">All Countries (${state.channels.length})</option>`;
                    sorted.forEach(c => {
                        const count = state.channels.filter(ch => ch.code && ch.code.toUpperCase() === c).length;
                        select.innerHTML += `<option value="${c}" ${state.filter === c ? 'selected' : ''}>${getCountryName(c)} (${count})</option>`;
                    });
                    els.filtersArea.appendChild(select);

                } else {
                    // Chips for Sports - Ordered: All, Soccer, then others alphabetically
                    const sports = new Set();
                    state.events.forEach(e => { if (e.sport_category) sports.add(e.sport_category); });

                    const scroll = document.createElement('div');
                    scroll.className = 'chips-scroll';

                    const addChip = (name) => {
                        const chip = document.createElement('div');
                        chip.className = `chip ${state.filter === name ? 'active' : ''}`;
                        chip.innerText = name === 'All' ? 'All Sports' : name;
                        chip.onclick = () => { state.filter = name; renderFilters(); renderContent(); };
                        scroll.appendChild(chip);
                    };

                    // Custom order: All first, then Soccer, then others sorted
                    addChip('All');
                    if (sports.has('Soccer')) addChip('Soccer');
                    Array.from(sports).filter(s => s !== 'Soccer').sort().forEach(s => addChip(s));
                    els.filtersArea.appendChild(scroll);
                }
            }

            // --- EPG Logic ---
            async function fetchEPG() {
                try {
                    // Check local storage first
                    const cached = localStorage.getItem('epgData');
                    const cachedTime = localStorage.getItem('epgTime');
                    const now = Date.now();

                    // Cache for 2 hours
                    if (cached && cachedTime && (now - parseInt(cachedTime) < 7200000)) {
                        processEPG(JSON.parse(cached));
                        return;
                    }

                    console.log('DEBUG: Fetching EPG Data...');
                    const res = await fetch('https://kuzwbdweiphaouenogef.supabase.co/functions/v1/epg-data?v=v12');
                    const data = await res.json();

                    if (data.success) {
                        processEPG(data.data);
                        localStorage.setItem('epgData', JSON.stringify(data.data));
                        localStorage.setItem('epgTime', now.toString());
                    }
                } catch (e) {
                    console.error('EPG Fetch Error:', e);
                }
            }

            function normalizeName(name) {
                return name.toLowerCase().replace(/[^a-z0-9]/g, '').replace(/(hd|fhd|tv)$/g, '');
            }

            function processEPG(data) {
                state.epg = data;
                state.epgMap.clear();

                Object.keys(data).forEach(key => {
                    // Map the key itself
                    state.epgMap.set(normalizeName(key), key);
                    // Map the display name
                    if (data[key].name) {
                        state.epgMap.set(normalizeName(data[key].name), key);
                    }
                });
                console.log('DEBUG: EPG Processed. Map size:', state.epgMap.size);
                renderContent(); // Refresh list to show EPG
            }

            function getCurrentProgram(channelName) {
                if (!state.epg || !channelName) return null;

                const norm = normalizeName(channelName);
                const epgKey = state.epgMap.get(norm);
                if (!epgKey) return null;

                const channelData = state.epg[epgKey];
                if (!channelData || !channelData.epg_data) return null;

                const now = new Date();
                const program = channelData.epg_data.find(p => {
                    const start = new Date(p.start);
                    const stop = new Date(p.stop);
                    return now >= start && now < stop;
                });

                return program ? { ...program, channelLogo: channelData.logo } : null; // Logo might not be there but good to have
            }

            function formatEPGTime(dateStr) {
                const date = new Date(dateStr);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            // --- Rendering Content ---
            function renderContent() {
                els.contentList.innerHTML = '';

                const query = els.search.value.toLowerCase();
                let source = state.tab === 'channels' ? state.channels : state.events;

                // 1. Filter Category
                if (state.filter !== 'All') {
                    if (state.tab === 'channels') source = source.filter(i => i.code && i.code.toUpperCase() === state.filter);
                    else source = source.filter(i => i.sport_category === state.filter);
                }

                // 2. Filter Search
                if (query) {
                    source = source.filter(i => i.name.toLowerCase().includes(query));
                }

                // 3. Render
                if (state.tab === 'channels') renderChannelList(source);
                else renderEventGrid(source);
            }

            function renderChannelList(items) {
                els.contentList.className = 'content-scroll channel-list'; // apply list class

                // Display all channels (no limit)
                items.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'channel-item';
                    el.onclick = () => playStream(item, el);

                    // Logo Fallback
                    const fallbackLogo = `https://ui-avatars.com/api/?name=${item.name}&background=random&color=fff&size=48`;
                    const imgUrl = item.image || fallbackLogo;

                    // Status Logic
                    const isOnline = item.status === 'online';
                    const statusHtml = isOnline
                        ? `<span class="status-badge online">‚óè Online</span>`
                        : `<span class="status-badge offline">‚óã Offline</span>`;

                    const epgProgram = getCurrentProgram(item.name);

                    el.innerHTML = `
                <img src="${imgUrl}" class="channel-logo" loading="lazy" onerror="this.src='${fallbackLogo}'">
                <div class="channel-info">
                    <div class="channel-name">${item.name}</div>
                    <div class="channel-meta">
                        <span class="flag-badge">${item.code || 'TV'}</span>
                        ${epgProgram ? `
                            <span style="color: #6366f1; margin: 0 4px;">‚Ä¢</span>
                            <span style="color: #a1a1aa; font-size: 0.85em; overflow: hidden; text-overflow: ellipsis;">
                                ${formatEPGTime(epgProgram.start)} - ${epgProgram.title}
                            </span>
                        ` : ''}
                    </div>
                </div>
                ${item.status === 'online' ? '<span class="status-badge online">‚óè LIVE</span>' : ''}
            `;
                    els.contentList.appendChild(el);
                });
            }

            function renderEventGrid(items) {
                els.contentList.className = 'content-scroll channel-list'; // Use list layout

                if (items.length === 0) {
                    els.contentList.innerHTML = '<div style="padding:20px; color:#666; text-align:center;">No events found in this category.</div>';
                    return;
                }

                // Group events by gameID to avoid duplicates
                const groupedEvents = new Map();
                items.forEach(item => {
                    const key = item.gameID || item.match_info || item.name;
                    if (!groupedEvents.has(key)) {
                        groupedEvents.set(key, { event: item, channels: [] });
                    }
                    groupedEvents.get(key).channels.push({
                        name: item.channel_name,
                        url: item.url,
                        code: item.code
                    });
                });

                // Convert to array, filter out events without channels, and separate live/upcoming
                const uniqueEvents = Array.from(groupedEvents.values()).filter(g => g.channels.length > 0);

                const liveEvents = uniqueEvents.filter(g => {
                    const item = g.event;
                    if (item.status === 'live') {
                        // Stale check using 'end' date
                        if (item.end) {
                            const endDate = new Date(item.end.replace(' ', 'T') + 'Z'); // Parse as UTC
                            // Hide immediately if current time is past end time
                            if (new Date() > endDate) {
                                return false;
                            }
                        } else if (item.start) {
                            // Fallback to start time heuristic if 'end' is missing
                            const startDate = new Date(item.start.replace(' ', 'T') + 'Z');
                            const startDiff = (new Date() - startDate) / 1000 / 60;
                            if (startDiff > 180) return false;
                        }
                        // Sort live by time
                        return true;
                    }
                    return false;
                }).sort((a, b) => (a.event.start || '').localeCompare(b.event.start || ''));

                const upcomingEvents = uniqueEvents.filter(g => {
                    if (g.event.status === 'live') return false;
                    // Only show events that haven't started yet
                    if (g.event.start) {
                        // API returns UTC times - parse as UTC, not local time
                        const startDate = new Date(g.event.start.replace(' ', 'T') + 'Z');
                        if (new Date() > startDate) return false; // Already started
                    }
                    return true;
                }).sort((a, b) => (a.event.start || '').localeCompare(b.event.start || ''));

                // Render Live Events Section
                if (liveEvents.length > 0) {
                    const liveHeader = document.createElement('div');
                    liveHeader.style.cssText = 'padding: 8px 12px; background: rgba(239, 68, 68, 0.15); border-radius: 8px; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;';
                    liveHeader.innerHTML = '<span class="live-indicator"></span><span style="color: #ef4444; font-weight: 600;">LIVE NOW (' + liveEvents.length + ')</span>';
                    els.contentList.appendChild(liveHeader);

                    liveEvents.forEach(group => renderEventRow(group, true));
                }

                // Render Upcoming Events Section
                if (upcomingEvents.length > 0) {
                    const upcomingHeader = document.createElement('div');
                    upcomingHeader.style.cssText = 'padding: 8px 12px; background: rgba(99, 102, 241, 0.15); border-radius: 8px; margin: 16px 0 8px 0; display: flex; align-items: center; gap: 8px;';
                    upcomingHeader.innerHTML = '<span style="color: #818cf8; font-weight: 600;">üìÖ UPCOMING (' + upcomingEvents.length + ')</span>';
                    els.contentList.appendChild(upcomingHeader);

                    upcomingEvents.forEach(group => renderEventRow(group, false));
                }
            }

            // Helper to format ISO/UTC string to local HH:MM
            function getLocalTime(item) {
                if (item.start) {
                    try {
                        const date = new Date(item.start.replace(' ', 'T') + 'Z');
                        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                    } catch (e) { }
                }
                return item.time || 'TBD';
            }



            function renderEventRow(group, isLive) {
                const item = group.event;
                const channels = group.channels;

                const container = document.createElement('div');
                container.style.cssText = 'margin-bottom: 4px;';

                // Main event row
                const el = document.createElement('div');
                el.className = 'channel-item';
                el.style.cursor = 'pointer';

                const matchTitle = formatEventTitle(item.name);
                const competition = item.tournament || item.sport_category || '';
                const flagUrl = item.countryIMG || '';

                el.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px; min-width: 60px;">
                    ${isLive ? '<span class="live-indicator"></span>' : ''}
                    <span style="color: ${isLive ? '#ef4444' : '#888'}; font-size: 0.85rem; font-weight: 600;">${getLocalTime(item)}</span>
                </div>
                <div class="channel-info" style="flex: 1;">
                    <div class="channel-name">${matchTitle}</div>
                    <div class="channel-meta" style="display: flex; align-items: center; gap: 8px;">
                        ${flagUrl ? `<img src="${flagUrl}" style="width: 16px; height: 12px; border-radius: 2px;" onerror="this.style.display='none'">` : ''}
                        <span style="color: #06b6d4; font-size: 0.75rem;">${competition}</span>
                        ${channels.length > 1 ? '<span style="color: #888; font-size: 0.7rem;">‚Ä¢ ' + channels.length + ' channels</span>' : ''}
                    </div>
                </div>
                ${channels.length > 1 ? '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="expand-arrow" style="color: #666; transition: transform 0.2s;"><polyline points="6 9 12 15 18 9"></polyline></svg>' : ''}
            `;

                // Channel selector (hidden by default)
                const channelList = document.createElement('div');
                channelList.className = 'channel-selector';
                channelList.style.cssText = 'display: none; padding: 8px 0 8px 68px; background: rgba(0,0,0,0.2); border-radius: 0 0 8px 8px;';

                if (channels.length > 1) {
                    // Expandable functionality
                    let expanded = false;
                    el.onclick = (e) => {
                        e.stopPropagation();
                        expanded = !expanded;
                        channelList.style.display = expanded ? 'block' : 'none';
                        const arrow = el.querySelector('.expand-arrow');
                        if (arrow) arrow.style.transform = expanded ? 'rotate(180deg)' : 'rotate(0deg)';
                    };

                    // Render channel options
                    channels.forEach((ch) => {
                        const channelItem = document.createElement('div');
                        channelItem.style.cssText = 'padding: 8px 12px; margin: 2px 0; border-radius: 6px; cursor: pointer; transition: background 0.2s; display: flex; align-items: center; gap: 10px;';
                        channelItem.onmouseover = () => channelItem.style.background = 'rgba(255,255,255,0.05)';
                        channelItem.onmouseout = () => channelItem.style.background = 'transparent';

                        // Create a temporary item object for this specific channel
                        // Use eventKey for grouping (gameID or match_info or name)
                        const eventKey = item.gameID || item.match_info || item.name;
                        const channelSpecificItem = {
                            ...item,
                            url: ch.url,
                            channel_name: ch.name,
                            code: ch.code,
                            eventKey: eventKey // For server list matching
                        };

                        channelItem.onclick = (e) => {
                            e.stopPropagation();
                            playStream(channelSpecificItem, channelItem);
                        };

                        const countryCode = ch.code ? ch.code.toLowerCase() : '';
                        const flagImgUrl = countryCode ? `https://flagcdn.com/w40/${countryCode}.png` : '';

                        channelItem.innerHTML = `
                        ${getStatusHtml(getChannelStatus(channelSpecificItem))}
                        ${flagImgUrl ? '<img src="' + flagImgUrl + '" style="width: 20px; height: 15px; border-radius: 2px; flex-shrink: 0;" onerror="this.style.display=\'none\'">' : ''}
                        <span style="color: #fff; font-size: 0.85rem; flex: 1;">${ch.name}</span>
                        <span style="color: #06b6d4; font-size: 0.7rem; text-transform: uppercase;">${ch.code || ''}</span>
                    `;
                        channelList.appendChild(channelItem);
                    });
                } else if (channels.length === 1) {
                    // Single channel - direct click
                    el.onclick = () => playStream(item, el);
                }

                container.appendChild(el);
                container.appendChild(channelList);
                els.contentList.appendChild(container);
            }

            function formatEventTitle(name) {
                if (!name) return "Unknown Event";
                try {
                    const parts = name.split(' - ');
                    if (parts.length >= 3) return parts[1];
                    if (parts.length === 2) return parts[1];
                    return name;
                } catch (e) {
                    return name;
                }
            }

            // --- Helpers ---
            function getChannelStatus(item) {
                const channelName = item.channel_name || item.name || '';

                // Normalize for matching
                const normalize = (str) => str.toLowerCase().trim().replace(/[^a-z0-9]/g, '');
                const normalizedName = normalize(channelName);

                // Lookup in state.channels by name
                const matchedChannel = state.channels.find(ch => {
                    const chName = normalize(ch.name || '');
                    return chName === normalizedName ||
                        normalizedName.includes(chName) ||
                        chName.includes(normalizedName);
                });

                if (matchedChannel && matchedChannel.status) {
                    return matchedChannel.status.toLowerCase();
                }

                // Fallback to item's own status
                if (item.status) {
                    return item.status.toLowerCase();
                }
                if (item.channel_status) {
                    return item.channel_status;
                }

                return 'offline'; // Default
            }

            function getStatusHtml(status) {
                const isOnline = status === 'online';
                return isOnline
                    ? `<span class="status-badge online" style="margin-right:8px;">‚óè Online</span>`
                    : `<span class="status-badge offline" style="margin-right:8px;">‚óã Offline</span>`;
            }

            function getCountryName(code) {
                const map = {
                    "AD": "Andorra", "AE": "United Arab Emirates", "AF": "Afghanistan", "AG": "Antigua and Barbuda", "AI": "Anguilla", "AL": "Albania", "AM": "Armenia", "AO": "Angola", "AR": "Argentina", "AS": "American Samoa", "AT": "Austria", "AU": "Australia", "AW": "Aruba", "AX": "√Öland Islands", "AZ": "Azerbaijan",
                    "BA": "Bosnia and Herzegovina", "BB": "Barbados", "BD": "Bangladesh", "BE": "Belgium", "BF": "Burkina Faso", "BG": "Bulgaria", "BH": "Bahrain", "BI": "Burundi", "BJ": "Benin", "BL": "Saint Barth√©lemy", "BM": "Bermuda", "BN": "Brunei Darussalam", "BO": "Bolivia", "BQ": "Bonaire", "BR": "Brazil", "BS": "Bahamas", "BT": "Bhutan", "BV": "Bouvet Island", "BW": "Botswana", "BY": "Belarus", "BZ": "Belize",
                    "CA": "Canada", "CC": "Cocos (Keeling) Islands", "CD": "Congo (DRC)", "CF": "Central African Republic", "CG": "Congo", "CH": "Switzerland", "CI": "C√¥te d'Ivoire", "CK": "Cook Islands", "CL": "Chile", "CM": "Cameroon", "CN": "China", "CO": "Colombia", "CR": "Costa Rica", "CU": "Cuba", "CV": "Cabo Verde", "CW": "Cura√ßao", "CX": "Christmas Island", "CY": "Cyprus", "CZ": "Czechia",
                    "DE": "Germany", "DJ": "Djibouti", "DK": "Denmark", "DM": "Dominica", "DO": "Dominican Republic", "DZ": "Algeria",
                    "EC": "Ecuador", "EE": "Estonia", "EG": "Egypt", "EH": "Western Sahara", "ER": "Eritrea", "ES": "Spain", "ET": "Ethiopia",
                    "FI": "Finland", "FJ": "Fiji", "FK": "Falkland Islands", "FM": "Micronesia", "FO": "Faroe Islands", "FR": "France",
                    "GA": "Gabon", "GB": "United Kingdom", "GD": "Grenada", "GE": "Georgia", "GF": "French Guiana", "GG": "Guernsey", "GH": "Ghana", "GI": "Gibraltar", "GL": "Greenland", "GM": "Gambia", "GN": "Guinea", "GP": "Guadeloupe", "GQ": "Equatorial Guinea", "GR": "Greece", "GS": "South Georgia", "GT": "Guatemala", "GU": "Guam", "GW": "Guinea-Bissau", "GY": "Guyana",
                    "HK": "Hong Kong", "HM": "Heard Island and McDonald Islands", "HN": "Honduras", "HR": "Croatia", "HT": "Haiti", "HU": "Hungary",
                    "ID": "Indonesia", "IE": "Ireland", "IL": "Israel", "IM": "Isle of Man", "IN": "India", "IO": "British Indian Ocean Territory", "IQ": "Iraq", "IR": "Iran", "IS": "Iceland", "IT": "Italy",
                    "JE": "Jersey", "JM": "Jamaica", "JO": "Jordan", "JP": "Japan",
                    "KE": "Kenya", "KG": "Kyrgyzstan", "KH": "Cambodia", "KI": "Kiribati", "KM": "Comoros", "KN": "Saint Kitts and Nevis", "KP": "North Korea", "KR": "South Korea", "KW": "Kuwait", "KY": "Cayman Islands", "KZ": "Kazakhstan",
                    "LA": "Laos", "LB": "Lebanon", "LC": "Saint Lucia", "LI": "Liechtenstein", "LK": "Sri Lanka", "LR": "Liberia", "LS": "Lesotho", "LT": "Lithuania", "LU": "Luxembourg", "LV": "Latvia", "LY": "Libya",
                    "MA": "Morocco", "MC": "Monaco", "MD": "Moldova", "ME": "Montenegro", "MF": "Saint Martin", "MG": "Madagascar", "MH": "Marshall Islands", "MK": "North Macedonia", "ML": "Mali", "MM": "Myanmar", "MN": "Mongolia", "MO": "Macao", "MP": "Northern Mariana Islands", "MQ": "Martinique", "MR": "Mauritania", "MS": "Montserrat", "MT": "Malta", "MU": "Mauritius", "MV": "Maldives", "MW": "Malawi", "MX": "Mexico", "MY": "Malaysia", "MZ": "Mozambique",
                    "NA": "Namibia", "NC": "New Caledonia", "NE": "Niger", "NF": "Norfolk Island", "NG": "Nigeria", "NI": "Nicaragua", "NL": "Netherlands", "NO": "Norway", "NP": "Nepal", "NR": "Nauru", "NU": "Niue", "NZ": "New Zealand",
                    "OM": "Oman",
                    "PA": "Panama", "PE": "Peru", "PF": "French Polynesia", "PG": "Papua New Guinea", "PH": "Philippines", "PK": "Pakistan", "PL": "Poland", "PM": "Saint Pierre and Miquelon", "PN": "Pitcairn", "PR": "Puerto Rico", "PS": "Palestine", "PT": "Portugal", "PW": "Palau", "PY": "Paraguay",
                    "QA": "Qatar",
                    "RE": "R√©union", "RO": "Romania", "RS": "Serbia", "RU": "Russia", "RW": "Rwanda",
                    "SA": "Saudi Arabia", "SB": "Solomon Islands", "SC": "Seychelles", "SD": "Sudan", "SE": "Sweden", "SG": "Singapore", "SH": "Saint Helena", "SI": "Slovenia", "SJ": "Svalbard and Jan Mayen", "SK": "Slovakia", "SL": "Sierra Leone", "SM": "San Marino", "SN": "Senegal", "SO": "Somalia", "SR": "Suriname", "SS": "South Sudan", "ST": "Sao Tome and Principe", "SV": "El Salvador", "SX": "Sint Maarten", "SY": "Syria", "SZ": "Eswatini",
                    "TC": "Turks and Caicos Islands", "TD": "Chad", "TF": "French Southern Territories", "TG": "Togo", "TH": "Thailand", "TJ": "Tajikistan", "TK": "Tokelau", "TL": "Timor-Leste", "TM": "Turkmenistan", "TN": "Tunisia", "TO": "Tonga", "TR": "Turkey", "TT": "Trinidad and Tobago", "TV": "Tuvalu", "TW": "Taiwan", "TZ": "Tanzania",
                    "UA": "Ukraine", "UG": "Uganda", "UM": "United States Minor Outlying Islands", "US": "USA", "UY": "Uruguay", "UZ": "Uzbekistan",
                    "VA": "Holy See", "VC": "Saint Vincent and the Grenadines", "VE": "Venezuela", "VG": "Virgin Islands (British)", "VI": "Virgin Islands (U.S.)", "VN": "Vietnam", "VU": "Vanuatu",
                    "WF": "Wallis and Futuna", "WS": "Samoa",
                    "YE": "Yemen", "YT": "Mayotte",
                    "ZA": "South Africa", "ZM": "Zambia", "ZW": "Zimbabwe"
                };
                return map[code] || code;
            }

            els.search.addEventListener('input', renderContent);

            // --- Player Logic ---
            async function playStream(item, el) {
                console.log('DEBUG: playStream called for', item.name || 'Unknown');

                // Show loading toast
                const loadingToast = document.getElementById('loadingToast');
                const loadingToastText = document.getElementById('loadingToastText');
                if (loadingToast) {
                    loadingToastText.innerText = `Loading ${item.channel_name || item.name || 'stream'}...`;
                    loadingToast.style.display = 'flex';
                }

                // Show spinner
                const playerLoader = document.getElementById('playerLoader');
                if (playerLoader) playerLoader.style.display = 'flex';

                currentStreamUrl = null;
                // Highlight
                document.querySelectorAll('.channel-item, .event-card').forEach(i => i.classList.remove('playing'));
                if (el) el.classList.add('playing');

                els.placeholder.style.display = 'none';
                els.video.style.display = 'block';

                // Show custom integrated controls
                document.getElementById('customControls').style.display = 'flex';
                setupCustomControls();

                const showError = (msg) => {
                    const t = document.getElementById('errorToast');
                    t.innerText = msg;
                    t.style.display = 'block';
                    setTimeout(() => t.style.display = 'none', 4000);
                    if (playerLoader) playerLoader.style.display = 'none';
                    if (loadingToast) loadingToast.style.display = 'none';
                };

                try {
                    const res = await fetch(`/api/stream?url=${encodeURIComponent(item.url)}`);
                    const data = await res.json();
                    if (data.success) {
                        console.log('DEBUG: Stream URL fetched:', data.streamUrl);
                        console.log('DEBUG: Raw URL available:', data.rawUrl);
                        currentStreamUrl = data.streamUrl;
                        window.rawStreamUrl = data.rawUrl; // Store globally
                    } else {
                        console.error('DEBUG: Failed to fetch stream URL:', data);
                    }

                    if (data.success && data.streamUrl) {
                        if (Hls.isSupported()) {
                            if (hls) hls.destroy();
                            hls = new Hls();
                            hls.loadSource(data.streamUrl);
                            hls.attachMedia(els.video);
                            hls.on(Hls.Events.MANIFEST_PARSED, () => els.video.play());
                            hls.on(Hls.Events.ERROR, (e, d) => {
                                if (d.fatal) showError("Stream connection lost");
                            });
                        } else if (els.video.canPlayType('application/vnd.apple.mpegurl')) {
                            els.video.src = data.streamUrl;
                            els.video.play();
                        }

                        // Hide spinner and toast when video plays
                        els.video.onplaying = () => {
                            if (playerLoader) playerLoader.style.display = 'none';
                            if (loadingToast) loadingToast.style.display = 'none';
                        };
                        els.video.onwaiting = () => {
                            if (playerLoader) playerLoader.style.display = 'flex';
                        };
                    } else {
                        showError("Channel Offline (404)");
                    }
                } catch (e) {
                    showError("Connection Failed");
                }

                // Render server list
                renderServerList(item);
            }

            // --- Custom Controls Setup ---
            let controlsSetup = false;
            let controlsTimeout = null;

            function setupCustomControls() {
                console.log('DEBUG: setupCustomControls called');
                if (controlsSetup) return;
                controlsSetup = true;

                const video = els.video;
                const controls = document.getElementById('customControls');
                const progressBar = document.getElementById('progressBar');
                const currentTimeEl = document.getElementById('currentTime');
                const durationEl = document.getElementById('duration');
                const playIcon = document.getElementById('playIcon');
                const pauseIcon = document.getElementById('pauseIcon');
                const volumeBar = document.getElementById('volumeBar');
                const playerArea = document.querySelector('.player-area');

                // Format time helper
                const formatTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                };

                // Update time and progress
                video.addEventListener('timeupdate', () => {
                    const percent = (video.currentTime / video.duration) * 100;
                    progressBar.value = percent || 0;
                    currentTimeEl.textContent = formatTime(video.currentTime);
                });

                // Update duration display
                video.addEventListener('loadedmetadata', () => {
                    durationEl.textContent = formatTime(video.duration);
                });

                // Progress bar seeking
                progressBar.addEventListener('input', (e) => {
                    const time = (e.target.value / 100) * video.duration;
                    video.currentTime = time;
                });

                // Play/pause icon toggle
                video.addEventListener('play', () => {
                    playIcon.style.display = 'none';
                    pauseIcon.style.display = 'block';
                });

                video.addEventListener('pause', () => {
                    playIcon.style.display = 'block';
                    pauseIcon.style.display = 'none';
                });

                // Volume control
                volumeBar.addEventListener('input', (e) => {
                    video.volume = e.target.value / 100;
                });

                // Auto-hide controls
                const showControls = () => {
                    controls.style.opacity = '1';
                    clearTimeout(controlsTimeout);
                    if (!video.paused) {
                        controlsTimeout = setTimeout(() => {
                            controls.style.opacity = '0';
                        }, 3000);
                    }
                };

                playerArea.addEventListener('mousemove', showControls);
                playerArea.addEventListener('mouseenter', showControls);
                video.addEventListener('play', () => setTimeout(showControls, 100));
                video.addEventListener('pause', () => {
                    clearTimeout(controlsTimeout);
                    controls.style.opacity = '1';
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;

                    switch (e.key) {
                        case ' ':
                        case 'k':
                            e.preventDefault();
                            togglePlayPause();
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            video.currentTime = Math.max(0, video.currentTime - 5);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            video.currentTime = Math.min(video.duration, video.currentTime + 5);
                            break;
                        case 'f':
                            e.preventDefault();
                            toggleFullscreen();
                            break;
                        case 'm':
                            e.preventDefault();
                            toggleMute();
                            break;
                    }
                });

                // Manual attach for Cast (Debug)
                const castBtn = document.getElementById('castBtn');
                if (castBtn) {
                    console.log('DEBUG: Attaching manual click listener to CastBtn');
                    castBtn.addEventListener('click', (e) => {
                        console.log('DEBUG: CastBtn clicked (Manual Listener)');
                        if (window.openCastDialog) window.openCastDialog();
                    });
                }

                // Initial show
                showControls();
            }

            // Control Functions
            function togglePlayPause() {
                const video = els.video;
                if (video.paused) {
                    video.play();
                } else {
                    video.pause();
                }
            }

            function toggleMute() {
                const video = els.video;
                video.muted = !video.muted;
                document.getElementById('volumeBar').value = video.muted ? 0 : video.volume * 100;
            }

            function toggleFullscreen() {
                const playerArea = document.querySelector('.player-area');
                if (!document.fullscreenElement) {
                    playerArea.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }

            // --- AirPlay ---
            async function toggleAirPlay() {
                const video = document.getElementById('videoPlayer');
                // Use Remote Playback API for AirPlay
                if (video.remote) {
                    try {
                        await video.remote.prompt();
                    } catch (e) {
                        if (e.name !== 'NotAllowedError') {
                            // Show toast with instructions
                            const toast = document.getElementById('errorToast');
                            toast.innerText = 'üì∫ AirPlay: Use Safari or enable in browser settings';
                            toast.style.background = '#3b82f6';
                            toast.style.display = 'block';
                            setTimeout(() => {
                                toast.style.display = 'none';
                                toast.style.background = '#ef4444';
                            }, 4000);
                        }
                    }
                } else {
                    const toast = document.getElementById('errorToast');
                    toast.innerText = 'üì∫ AirPlay requires Safari browser';
                    toast.style.background = '#3b82f6';
                    toast.style.display = 'block';
                    setTimeout(() => {
                        toast.style.display = 'none';
                        toast.style.background = '#ef4444';
                    }, 4000);
                }
            }

            // --- Picture-in-Picture ---
            async function togglePiP() {
                const video = document.getElementById('videoPlayer');
                try {
                    if (document.pictureInPictureElement) {
                        await document.exitPictureInPicture();
                    } else if (document.pictureInPictureEnabled) {
                        await video.requestPictureInPicture();
                    } else {
                        alert('Picture-in-Picture not supported in this browser');
                    }
                } catch (e) {
                    console.error('PiP Error:', e);
                }
            }

            // --- Chromecast (Google Cast SDK) ---
            let castSession = null;

            // Initialize Cast API on window load
            window['__onGCastApiAvailable'] = function (isAvailable) {
                console.log('Cast API Available:', isAvailable);
                if (isAvailable) {
                    try {
                        initializeCastApi();
                    } catch (e) {
                        console.error('Failed to initialize Cast API:', e);
                    }
                }
            };

            function initializeCastApi() {
                console.log('Initializing Cast API...');
                const options = {
                    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
                };
                cast.framework.CastContext.getInstance().setOptions(options);
                console.log('Cast API initialized with default receiver');
            }

            window.openCastDialog = async function () {
                console.log('DEBUG: openCastDialog called (Global)');

                try {
                    // Try Cast SDK first
                    if (typeof cast !== 'undefined' && cast.framework) {
                        console.log('DEBUG: Using Cast SDK');
                        const castContext = cast.framework.CastContext.getInstance();
                        console.log('DEBUG: Requesting Cast Session...');
                        await castContext.requestSession();
                        console.log('DEBUG: Session request completed');

                        castSession = castContext.getCurrentSession();
                        if (castSession) {
                            const video = document.getElementById('videoPlayer');
                            // Use RAW URL for Chromecast (Residential IP)
                            const streamSrc = window.rawStreamUrl || currentStreamUrl || video.src;
                            console.log('DEBUG: Attempting to cast URL:', streamSrc);

                            if (!streamSrc) {
                                console.error('DEBUG: No stream URL available explicitly or in video.src');
                                showCastInstructions();
                                return;
                            }

                            // Verify if URL is valid (basic check)
                            if (!streamSrc.startsWith('http')) {
                                console.warn('DEBUG: URL does not start with http(s), might fail on Chromecast:', streamSrc);
                            }

                            const mediaInfo = new chrome.cast.media.MediaInfo(streamSrc, 'application/x-mpegURL');
                            mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
                            mediaInfo.metadata.title = 'StreamSports Event';

                            const request = new chrome.cast.media.LoadRequest(mediaInfo);
                            console.log('DEBUG: Sending LoadRequest to Chromecast...', request);

                            try {
                                await castSession.loadMedia(request);
                                console.log('DEBUG: Casting started successfully');
                            } catch (loadError) {
                                console.error('DEBUG: castSession.loadMedia failed', loadError);
                                if (loadError.code) console.error('DEBUG: Error Code:', loadError.code);
                                if (loadError.description) console.error('DEBUG: Error Description:', loadError.description);
                                // Show toast
                                const t = document.getElementById('errorToast');
                                t.innerText = 'Chromecast Load Error: ' + (loadError.description || loadError.code || 'Unknown');
                                t.style.display = 'block';
                                setTimeout(() => t.style.display = 'none', 5000);
                            }
                        }
                    } else {
                        console.log('Cast SDK not available, trying Remote Playback API');
                        // Fallback: Remote Playback API
                        const video = document.getElementById('videoPlayer');
                        if (video.remote) {
                            await video.remote.prompt();
                            console.log('Remote playback started');
                        } else {
                            console.warn('No casting API available');
                            showCastInstructions();
                        }
                    }
                } catch (e) {
                    console.error('DEBUG: Cast error:', e);
                    if (e.name !== 'NotAllowedError') {
                        showCastInstructions();
                    }
                }
            }

            function showCastInstructions() {
                // Label suppressed by user request
                console.log('DEBUG: Chromecast warning suppressed');
            }

            // --- AirPlay ---
            async function toggleAirPlay() {
                console.log('AirPlay button clicked');
                const video = document.getElementById('videoPlayer');

                // Use Remote Playback API for AirPlay
                if (video.remote) {
                    try {
                        console.log('Prompting for AirPlay device...');
                        await video.remote.prompt();
                        console.log('AirPlay started');
                    } catch (e) {
                        console.error('AirPlay error:', e);
                        if (e.name !== 'NotAllowedError') {
                            const toast = document.getElementById('errorToast');
                            toast.innerText = 'üì∫ AirPlay: Use Safari browser for best support';
                            toast.style.background = '#3b82f6';
                            toast.style.display = 'block';
                            setTimeout(() => {
                                toast.style.display = 'none';
                                toast.style.background = '#ef4444';
                            }, 4000);
                        }
                    }
                } else {
                    console.warn('Remote Playback API not available');
                    const toast = document.getElementById('errorToast');
                    toast.innerText = 'üì∫ AirPlay requires Safari browser';
                    toast.style.background = '#3b82f6';
                    toast.style.display = 'block';
                    setTimeout(() => {
                        toast.style.display = 'none';
                        toast.style.background = '#ef4444';
                    }, 4000);
                }
            }

            // --- Picture-in-Picture ---
            async function togglePiP() {
                const video = document.getElementById('videoPlayer');
                try {
                    if (document.pictureInPictureElement) {
                        await document.exitPictureInPicture();
                    } else if (document.pictureInPictureEnabled) {
                        await video.requestPictureInPicture();
                    } else {
                        alert('Picture-in-Picture not supported in this browser');
                    }
                } catch (e) {
                    console.error('PiP Error:', e);
                }
            }

            console.log('DEBUG: Script parsing finished, calling init() and EPG');
            fetchEPG(); // Start fetching EPG
            init();
            var currentTab = 'channels'; // Global needed for stats

            // --- Server List (Sibling Channels) ---
            function renderServerList(currentItem) {
                console.log('DEBUG: renderServerList called with:', currentItem);
                const container = document.getElementById('serverListContainer');
                const list = document.getElementById('serverList');

                if (!container || !list) {
                    console.log('DEBUG: serverList container not found');
                    return;
                }

                // Use eventKey for matching (same logic as grouping)
                const eventKey = currentItem.eventKey || currentItem.gameID || currentItem.match_info || currentItem.name;

                if (!eventKey) {
                    console.log('DEBUG: No eventKey, hiding server list');
                    container.style.display = 'none';
                    return;
                }

                // Find siblings by eventKey
                let siblings = [];
                const event = state.events.find(e => {
                    const eKey = e.gameID || e.match_info || e.name;
                    return eKey === eventKey;
                });

                console.log('DEBUG: Found parent event:', event);

                // Get channels from the grouped events map or from state.events
                if (event) {
                    // Find all events with the same key and collect their channels
                    siblings = state.events
                        .filter(e => (e.gameID || e.match_info || e.name) === eventKey)
                        .map(e => ({
                            name: e.channel_name || e.name,
                            url: e.url,
                            code: e.code,
                            country: e.country || '',
                            channel_name: e.channel_name
                        }));
                }

                // Deduplicate by URL
                siblings = siblings.filter((c, index, self) =>
                    index === self.findIndex((t) => (t.url === c.url))
                );

                if (siblings.length < 2) {
                    container.style.display = 'none';
                    return;
                }

                // Show container
                container.style.display = 'flex';
                list.innerHTML = '';

                siblings.forEach(ch => {
                    const btn = document.createElement('div');
                    const isActive = ch.url === currentItem.url;
                    btn.className = `server-btn ${isActive ? 'active' : ''}`;

                    let icon = '';
                    if (ch.code) icon = `<img src="https://flagcdn.com/20x15/${ch.code.toLowerCase()}.png">`;

                    btn.innerHTML = `
                        ${icon}
                        <div class="server-info">
                            <span class="server-name">${ch.channel_name || ch.name}</span>
                            <span class="server-meta">${ch.country || ''}</span>
                        </div>
                    `;

                    btn.onclick = (e) => {
                        e.stopPropagation();
                        // Preserve eventKey so server list stays visible
                        if (!isActive) playStream({ ...ch, eventKey: eventKey }, null);
                    };

                    list.appendChild(btn);
                });
            }
        </script>
</body>

</html>